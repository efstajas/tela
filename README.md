## ðŸ–¼ Tela 

Tela is a small framework for building [Intercom Canvas Kit applications](https://developers.intercom.com/building-apps/docs/canvas-kit). Write your apps as simple classes, run a server to receive calls to your app with one line, and get your canvasses type-checked with Typescript.

### â¬‡ï¸ Install

Simply install with npm or yarn.

```
npm install @efstajas/tela

or

yarn add @efstajas/tela
```

### ðŸŽ¬ Getting started

In Tela, you define Canvas Kit apps as simple classes that match the webhooks generated by Intercom for an app. The simplest possible app thus has only one handler `initialize`.

#### ðŸ¤š Handlers

In each app you can define up to three handlers: `initialize`, `submit` and `configure`. To understand what they're for, it's best to read [Intercom's documentation](https://developers.intercom.com/building-apps/docs/canvas-kit). You'll need to define an `initialize` handler at least, but if you need `submit` and / or `configure` handlers too depends entirely on your usecase.

```ts
//your-app.ts
import { App, Component } from '@efstajas/tela'

export default class ExampleApp implements App {
  public initialize = (body): Component[] => {
    return [
      {
        type: 'text',
        text: 'Hello world',
        style: 'paragraph'
      }
    ]
  }
}
```

For your convenience, these handlers are a bit magic: Instead of handling response sending and canvas creation manually in each handler, you simply return either an array of Components or a Promise that resolves to an array of Components directly. Tela will automatically take care of wrapping your components to create a valid canvas definition and send it back to Intercom once your handler has resolved.

If you need to read information that Intercom sends with the requests, worry not: The first argument for your handler is Intercom's request `body`.

#### ðŸŒ Handler Context

Alongside the request `body` passed from Intercom, your handler also receives a `context` object as the second argument. The context includes the current app name your handler is running in, the app's base endpoint URL and two objects `hooks` and `methods`, which you can use to find out the app's other handler's endpoints at runtime.

```ts
public initialize = (requestBody, context: HandlerContext) => {
  logger.log('Initialize request', LOGGER_NAME)

  const {
    endpoint,
    appName,
    hooks,
    methods
  } = context

  console.log(`
    This handler's path is ${endpoint}.
    It's part of app ${appName}.
  `)

  /*
  The hooks and methods objects are helpful for registering a webhook
  with one of your handlers at runtime, for example.
  Let's say that in response to an action on Intercom you want to make an
  API call that establishes a webhook to a handler in this app:

  service.createWebhook({
    url: `${hostname}${hooks.hookName.endpoint}`
  })
  */

  return [
    {
      type: 'text',
      text: 'Hello world',
      style: 'paragraph'
    }
  ]
}
```

#### ðŸ”Œ Receiving webhooks in your app

If you additionally need to receive external webhooks for your app, you can define hook handlers in a `public hooks` object:

```ts
public hooks = {
  hookName: (req, res, next, context) => {
    logger.log('Handling hookName hook', LOGGER_NAME)

    res.send(200)
    next()
  }
}
```

These handlers are defined as standard Express middleware. Each defined hook will be initialized at `/appname/hookname*`.

#### âœ… Starting the server

After writing your app, simply register it and start the server:

```ts
import Tela from '@efstajas/tela'

// Import your app class
import App from './app'

const tela = new Tela()

try {
  tela.registerApp('test', new App()).then((context) => {
    console.log('App initialized', context)
  })
} catch (e) {
  console.error(e)
}

tela.listen(8000).then(() => {
  console.log(`Listening at 8000`)
}).catch((e) => {
  console.error(e)
})
```

Of course, you can run multiple apps at the same time by calling `registerApp` multiple times before calling `listen`. Each app will be initialized at `/appname/handlername`. `registerApp` also returns a `context` object that includes the paths for all handlers that were initialized within your app.